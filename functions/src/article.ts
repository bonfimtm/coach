import { initializeApp } from 'firebase-admin/app';
import { getDownloadURL, getStorage } from 'firebase-admin/storage';
import { JWT } from 'google-auth-library';
import { GoogleSpreadsheet } from 'google-spreadsheet';
import * as path from 'path';
import { any, identity, ifElse, isNotNil } from 'ramda';

initializeApp();

interface Article {
  id: number;
  live: boolean;
  title: string;
  imageUrl: string;
  link: string;
  segments: [Segment];
}

interface Segment {
  element: SegmentType;
  content: string;
}


enum SegmentType {
  H1 = 'h1',
  H2 = 'h2',
  H3 = 'h3',
  H4 = 'h4',
  H5 = 'h5',
  H6 = 'h6',
  P = 'p',
  UL = 'ul',
}

const segmentTypeValues = Object.values(SegmentType);


const getServiceAccountAuth = (): JWT => {
  return new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: (process.env.GOOGLE_PRIVATE_KEY ?? '').split(String.raw`\n`).join('\n'),
    scopes: [
      'https://www.googleapis.com/auth/spreadsheets',
    ],
  });
};

const cellValueToBoolean = (cellValue: string) => cellValue == 'TRUE';

const cleanUpCellElement = (cellElement: string) => cellElement.trim().toLowerCase();

const cleanUpCellText = (cellContent: string) => cellContent.trim();

export const findAllArticles = async (sheetMaxRange = 'A1:A100'): Promise<Partial<Article>[]> => {
  const serviceAccountAuth = getServiceAccountAuth();
  const doc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_ID ?? '', serviceAccountAuth);
  await doc.loadInfo();
  const articles = await Promise.all(
    doc.sheetsByIndex
      .map(async (sheet) => {
        await sheet.loadCells(sheetMaxRange);
        const rows = await sheet.getRows();
        const firstValueRow = rows[0];
        const id = sheet.index;
        const live = cellValueToBoolean(firstValueRow.get('live'));
        const title = cleanUpCellText(firstValueRow.get('title'));
        const link = cleanUpCellText(firstValueRow.get('link'));
        const segmentRows = rows
          .map((row) => {
            return {
              element: cleanUpCellElement(row.get('element')),
              content: cleanUpCellText(row.get('content')),
            };
          });
        const segments = segmentRows.filter((segment) => {
          return (segmentTypeValues as string[]).includes(segment.element) && !!segment.content;
        });
        return { id, live, title, link, segments } as Article;
      })
  );
  return articles;
};

export const findAllArticleImages = async (
  articleId: number | null,
  imageDir = 'img',
  sheetMaxRange = 'A1:A100',
): Promise<Partial<Article>> => {
  const serviceAccountAuth = getServiceAccountAuth();
  const doc = new GoogleSpreadsheet(process.env.GOOGLE_SHEET_ID ?? '', serviceAccountAuth);
  await doc.loadInfo();
  const imageUrl = await ifElse(
    () => isNotNil(articleId) && !isNaN(articleId),
    async () => {
      const id = articleId as number;
      if (id < 0 || id > doc.sheetCount - 1) {
        return null;
      }
      const sheet = doc.sheetsByIndex[id];
      await sheet.loadCells(sheetMaxRange);
      const rows = await sheet.getRows();
      const firstValueRow = rows[0];
      const bucket = getStorage().bucket();
      const imageFilename = cleanUpCellText(firstValueRow.get(imageDir));
      const imageFileRef = bucket.file(path.join(imageDir, imageFilename));
      const imageFileExists = any(identity, await imageFileRef.exists());
      return imageFileExists ? await getDownloadURL(imageFileRef) : null;
    },
    async () => null,
  )();
  return { imageUrl } as Partial<Article>;
};

